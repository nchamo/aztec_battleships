// Run with: tsx scripts/build-contracts.ts
// This script compiles Battleships contract and generates TypeScript wrappers

import { spawnSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';

// Output directory for artifacts (TypeScript wrappers)
const ARTIFACTS_OUTPUT_DIR = 'src/artifacts';
// Output directory for target JSONs (relative to src/, used by wrappers)
const TARGET_OUTPUT_DIR = 'src/target';
// Local contracts directory
const LOCAL_CONTRACTS_DIR = 'contracts';

/**
 * Try to run a command
 */
function tryRun(cmd: string, opts: Record<string, unknown> = {}): boolean {
  try {
    const res = spawnSync(cmd, { stdio: 'inherit', shell: '/bin/bash', ...opts });
    return res.status === 0;
  } catch {
    return false;
  }
}

/**
 * Ensure a directory exists
 */
function ensureDir(p: string): void {
  fs.mkdirSync(p, { recursive: true });
}

/**
 * Copy files with optional filter
 */
function copyFiles(
  sourceDir: string,
  targetDir: string,
  filter?: (file: string) => boolean
): number {
  if (!fs.existsSync(sourceDir)) {
    console.log(`âš ï¸ Source directory ${sourceDir} does not exist`);
    return 0;
  }

  ensureDir(targetDir);
  const files = fs.readdirSync(sourceDir);
  let copiedCount = 0;

  for (const file of files) {
    // Apply filter if provided
    if (filter && !filter(file)) {
      continue;
    }

    const srcPath = path.join(sourceDir, file);
    const dstPath = path.join(targetDir, file);

    // Overwrite or copy new
    if (fs.statSync(srcPath).isDirectory()) {
      fs.cpSync(srcPath, dstPath, { recursive: true, force: true });
    } else {
      fs.copyFileSync(srcPath, dstPath);
    }
    console.log(`   âœ… Copied ${file}`);
    copiedCount++;
  }

  console.log(`   ğŸ“Š Copied ${copiedCount} items`);
  return copiedCount;
}

/**
 * Generate TypeScript wrapper for Battleships contract
 */
function generateBattleshipsWrapper(projectRoot: string): void {
  const wrapperPath = path.join(projectRoot, ARTIFACTS_OUTPUT_DIR, 'Battleships.ts');

  const wrapperContent = `// Autogenerated file, do not edit!
// Generated from battleships contract
import { loadContractArtifact } from '@aztec/aztec.js/abi';
import { AztecAddress } from '@aztec/aztec.js/addresses';
import { Contract, ContractBase, DeployMethod } from '@aztec/aztec.js/contracts';
import { PublicKeys } from '@aztec/aztec.js/keys';
import type { ContractArtifact, ContractInstanceWithAddress } from '@aztec/aztec.js/abi';
import type { ContractFunctionInteraction, ContractMethod } from '@aztec/aztec.js/contracts';
import type { Wallet } from '@aztec/aztec.js/wallet';
import BattleshipsContractArtifactJson from '../target/battleships-Battleships.json' assert { type: 'json' };

export const BattleshipsContractArtifact = loadContractArtifact(BattleshipsContractArtifactJson as ContractArtifact);

/**
 * Type-safe interface for Battleships contract
 */
export class BattleshipsContract extends ContractBase {

  private constructor(
    instance: ContractInstanceWithAddress,
    wallet: Wallet
  ) {
    super(instance, BattleshipsContractArtifact, wallet);
  }

  /**
   * Creates a contract instance.
   * @param address - The deployed contract's address.
   * @param wallet - The wallet to use when interacting with the contract.
   * @returns A promise that resolves to a new Contract instance.
   */
  public static at(
    address: AztecAddress,
    wallet: Wallet
  ): Promise<BattleshipsContract> {
    return Contract.at(address, BattleshipsContract.artifact, wallet) as Promise<BattleshipsContract>;
  }

  /**
   * Creates a tx to deploy a new instance of this contract.
   */
  public static deploy(wallet: Wallet) {
    return new DeployMethod(PublicKeys.default(), wallet, BattleshipsContractArtifact, BattleshipsContract.at);
  }

  /**
   * Returns this contract's artifact.
   */
  public static get artifact(): ContractArtifact {
    return BattleshipsContractArtifact;
  }

  /** Type-safe wrappers for the public methods exposed by the contract. */
  public override methods!: {

    /** create_game(game_id: struct, board: struct, initial_shot: struct) */
    create_game: ((game_id: any, board: any, initial_shot: any) => ContractFunctionInteraction) &
      Pick<ContractMethod, 'selector'>;

    /** join_game(game_id: struct, board: struct, initial_shot: struct) */
    join_game: ((game_id: any, board: any, initial_shot: any) => ContractFunctionInteraction) &
      Pick<ContractMethod, 'selector'>;

    /** shoot(game_id: struct, turn: u32, shot: struct) */
    shoot: ((game_id: any, turn: any, shot: any) => ContractFunctionInteraction) &
      Pick<ContractMethod, 'selector'>;

    /** claim_abandonment(game_id: struct, turn: u32) */
    claim_abandonment: ((game_id: any, turn: any) => ContractFunctionInteraction) &
      Pick<ContractMethod, 'selector'>;

    /** get_game_status(game_id: struct) */
    get_game_status: ((game_id: any) => ContractFunctionInteraction) &
      Pick<ContractMethod, 'selector'>;
  };
}
`;

  fs.writeFileSync(wrapperPath, wrapperContent);
  console.log(`   âœ… Generated TypeScript wrapper: ${wrapperPath}`);
}

/**
 * Compile local contracts
 */
function compileLocalContracts(projectRoot: string): boolean {
  const contractsDir = path.join(projectRoot, LOCAL_CONTRACTS_DIR);

  if (!fs.existsSync(contractsDir)) {
    console.log(`âš ï¸ No local contracts directory found at ${contractsDir}`);
    return false;
  }

  // Find all contract directories (those with Nargo.toml)
  const contractDirs = fs.readdirSync(contractsDir).filter((dir) => {
    const nargoPath = path.join(contractsDir, dir, 'Nargo.toml');
    return fs.existsSync(nargoPath);
  });

  if (contractDirs.length === 0) {
    console.log('ğŸ“­ No local contracts found to compile');
    return false;
  }

  console.log(`\nğŸ”¨ Compiling ${contractDirs.length} local contract(s)...`);
  let allSuccess = true;

  for (const contractDir of contractDirs) {
    const contractPath = path.join(contractsDir, contractDir);
    const targetDir = path.join(contractPath, 'target');
    const artifactsDir = path.join(projectRoot, ARTIFACTS_OUTPUT_DIR);
    const targetOutputDir = path.join(projectRoot, TARGET_OUTPUT_DIR);

    console.log(`\n   ğŸ“¦ Processing ${contractDir}...`);

    // Check if we already have compiled artifacts
    const hasExistingArtifacts =
      fs.existsSync(targetDir) &&
      fs
        .readdirSync(targetDir)
        .some((f) => f.endsWith('.json'));

    // Try to compile using aztec compile (which runs nargo + transpiles public bytecode)
    let compiled = false;

    // Set up PATH to include aztec tools:
    // - $HOME/.aztec/current/bin: contains nargo, anvil, forge, etc.
    // - $HOME/.aztec/current/node_modules/.bin: contains aztec, bb, etc.
    const aztecBinPath = '$HOME/.aztec/current/bin';
    const aztecNodeBinPath = '$HOME/.aztec/current/node_modules/.bin';
    const pathSetup = `export PATH="${aztecBinPath}:${aztecNodeBinPath}:$PATH"`;

    // Try aztec compile (preferred - compiles AND transpiles public bytecode)
    if (tryRun(`bash -c '${pathSetup} && cd "${contractPath}" && aztec compile'`)) {
      console.log(`   âœ… ${contractDir} compiled with aztec compile`);
      compiled = true;
    }
    // Try nargo as fallback (WARNING: won't transpile public bytecode)
    else if (tryRun(`bash -c '${pathSetup} && cd "${contractPath}" && nargo compile'`)) {
      console.log(`   âš ï¸ ${contractDir} compiled with nargo (public bytecode NOT transpiled)`);
      compiled = true;
    }

    if (!compiled) {
      console.warn(
        `   âŒ Failed to compile ${contractDir} (no existing artifacts)`
      );
      allSuccess = false;
      continue;
    }

    // Ensure output directories exist
    ensureDir(artifactsDir);
    ensureDir(targetOutputDir);

    // Copy JSON artifacts to src/target
    if (fs.existsSync(targetDir)) {
      console.log(`\n   ğŸ“ Copying JSON artifacts to ${TARGET_OUTPUT_DIR}/`);
      copyFiles(
        targetDir,
        targetOutputDir,
        (file) => file.endsWith('.json')
      );
    }

    // Generate TypeScript wrapper
    console.log(`\n   ğŸ“ Generating TypeScript wrapper...`);
    generateBattleshipsWrapper(projectRoot);
  }

  return allSuccess;
}

async function main() {
  const projectRoot = process.cwd();

  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           BUILD BATTLESHIPS CONTRACT                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);

  try {
    console.log('='.repeat(60));
    console.log('ğŸ”¨ Compiling Battleships contract');
    console.log('='.repeat(60));

    if (!compileLocalContracts(projectRoot)) {
      console.warn('\nâš ï¸ Contract compilation had issues');
      process.exit(1);
    } else {
      console.log('\nâœ… Contract compiled successfully');
    }

    console.log('\n' + '='.repeat(60));
    console.log('ğŸ‰ Build complete!');
    console.log('='.repeat(60) + '\n');
  } catch (err: unknown) {
    const errorMessage = err instanceof Error ? err.message : String(err);
    console.error('\nâŒ Build script failed:', errorMessage);
    process.exit(1);
  }
}

main();
